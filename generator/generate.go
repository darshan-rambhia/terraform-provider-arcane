// Code generator for Terraform Provider Arcane.
//
// This tool reads a provider spec JSON file (generated by tfplugingen-openapi)
// and generates Terraform Framework resource/data source code from templates.
//
// Usage:
//
//	go run ./generator/... --spec spec/provider_spec.json --templates generator/crud_templates --output internal/provider
//
// The generator produces:
//   - {resource}_generated.go - Resource implementations
//   - {datasource}_data_source_generated.go - Data source implementations
//   - All generated files are marked with a header comment
package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

// CLI flags
var (
	specPath      = flag.String("spec", "", "Path to provider_spec.json (required)")
	templatesPath = flag.String("templates", "generator/crud_templates", "Path to templates directory")
	outputPath    = flag.String("output", "internal/provider", "Path to output directory")
	dryRun        = flag.Bool("dry-run", false, "Preview generated code without writing files")
	resourceName  = flag.String("resource", "", "Generate only this specific resource (optional)")
)

// ProviderSpec represents the top-level provider specification
type ProviderSpec struct {
	Provider    ProviderInfo     `json:"provider"`
	Resources   []ResourceSpec   `json:"resources"`
	DataSources []DataSourceSpec `json:"datasources"`
}

type ProviderInfo struct {
	Name string `json:"name"`
}

// ResourceSpec defines a Terraform resource
type ResourceSpec struct {
	Name   string     `json:"name"`
	Schema SchemaSpec `json:"schema"`
}

// DataSourceSpec defines a Terraform data source
type DataSourceSpec struct {
	Name   string     `json:"name"`
	Schema SchemaSpec `json:"schema"`
}

// SchemaSpec contains attributes for a resource or data source
type SchemaSpec struct {
	Attributes []AttributeSpec `json:"attributes"`
}

// AttributeSpec defines a single attribute
type AttributeSpec struct {
	Name        string    `json:"name"`
	String      *TypeSpec `json:"string,omitempty"`
	Int64       *TypeSpec `json:"int64,omitempty"`
	Bool        *TypeSpec `json:"bool,omitempty"`
	Float64     *TypeSpec `json:"float64,omitempty"`
	Description string    `json:"description,omitempty"`
}

// TypeSpec defines type-specific properties
type TypeSpec struct {
	ComputedOptionalRequired string `json:"computed_optional_required"`
	Description              string `json:"description,omitempty"`
	Sensitive                bool   `json:"sensitive,omitempty"`
}

// TemplateData is passed to templates during rendering
type TemplateData struct {
	// Resource/DataSource metadata
	ResourceName string // PascalCase name (e.g., "Environment")
	TypeName     string // snake_case name (e.g., "environment")
	Description  string

	// Attributes
	Attributes []AttributeData

	// Client method names
	CreateMethod     string
	ReadMethod       string
	UpdateMethod     string
	DeleteMethod     string
	ReadByNameMethod string
}

// AttributeData represents an attribute for template rendering
type AttributeData struct {
	Name        string // Original name from spec
	FieldName   string // PascalCase for Go struct field
	TFName      string // snake_case for TF schema
	Type        string // Go type (String, Int64, Bool, Float64)
	SchemaType  string // Schema type (String, Int64, Bool, Float64)
	Description string
	Required    bool
	Optional    bool
	Computed    bool
	Sensitive   bool
}

func main() {
	flag.Parse()

	if *specPath == "" {
		fmt.Fprintln(os.Stderr, "Error: --spec is required")
		fmt.Fprintln(os.Stderr, "Usage: go run ./generator/... --spec spec/provider_spec.json")
		os.Exit(1)
	}

	if err := run(); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}

func run() error {
	// Read and parse the spec file
	spec, err := readSpec(*specPath)
	if err != nil {
		return fmt.Errorf("failed to read spec: %w", err)
	}

	// Load templates
	templates, err := loadTemplates(*templatesPath)
	if err != nil {
		return fmt.Errorf("failed to load templates: %w", err)
	}

	// Generate resources
	for _, res := range spec.Resources {
		if *resourceName != "" && res.Name != *resourceName {
			continue
		}

		if err := generateResource(res, templates, *outputPath, *dryRun); err != nil {
			return fmt.Errorf("failed to generate resource %s: %w", res.Name, err)
		}
		fmt.Printf("Generated resource: %s\n", res.Name)
	}

	// Generate data sources
	for _, ds := range spec.DataSources {
		if *resourceName != "" && ds.Name != *resourceName {
			continue
		}

		if err := generateDataSource(ds, templates, *outputPath, *dryRun); err != nil {
			return fmt.Errorf("failed to generate data source %s: %w", ds.Name, err)
		}
		fmt.Printf("Generated data source: %s\n", ds.Name)
	}

	if *dryRun {
		fmt.Println("\nDry run complete - no files written")
	} else {
		fmt.Println("\nGeneration complete")
	}

	return nil
}

// readSpec reads and parses the provider spec JSON
func readSpec(path string) (*ProviderSpec, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		if os.IsNotExist(err) {
			return nil, fmt.Errorf("spec file not found: %s\nRun 'make fetch-spec generate-spec' to generate it", path)
		}
		return nil, err
	}

	var spec ProviderSpec
	if err := json.Unmarshal(data, &spec); err != nil {
		return nil, fmt.Errorf("failed to parse JSON: %w", err)
	}

	return &spec, nil
}

// loadTemplates loads all .tmpl files from the templates directory
func loadTemplates(dir string) (*template.Template, error) {
	tmpl := template.New("generator")

	entries, err := os.ReadDir(dir)
	if err != nil {
		return nil, fmt.Errorf("failed to read templates directory: %w", err)
	}

	for _, entry := range entries {
		if entry.IsDir() || !strings.HasSuffix(entry.Name(), ".tmpl") {
			continue
		}

		path := filepath.Join(dir, entry.Name())
		content, err := os.ReadFile(path)
		if err != nil {
			return nil, fmt.Errorf("failed to read template %s: %w", entry.Name(), err)
		}

		_, err = tmpl.New(entry.Name()).Parse(string(content))
		if err != nil {
			return nil, fmt.Errorf("failed to parse template %s: %w", entry.Name(), err)
		}
	}

	return tmpl, nil
}

// generateResource generates code for a resource
func generateResource(res ResourceSpec, templates *template.Template, outputDir string, dryRun bool) error {
	data := prepareTemplateData(res.Name, res.Schema)

	// Execute template
	tmpl := templates.Lookup("resource.go.tmpl")
	if tmpl == nil {
		return fmt.Errorf("resource.go.tmpl not found")
	}

	var buf strings.Builder
	if err := tmpl.Execute(&buf, data); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	// Add generation header
	code := addGenerationHeader(buf.String())

	if dryRun {
		fmt.Printf("\n=== %s_resource_generated.go ===\n%s\n", res.Name, code)
		return nil
	}

	// Write to file
	filename := filepath.Join(outputDir, fmt.Sprintf("%s_resource_generated.go", res.Name))
	if err := os.WriteFile(filename, []byte(code), 0600); err != nil {
		return fmt.Errorf("failed to write file: %w", err)
	}

	return nil
}

// generateDataSource generates code for a data source
func generateDataSource(ds DataSourceSpec, templates *template.Template, outputDir string, dryRun bool) error {
	data := prepareTemplateData(ds.Name, ds.Schema)

	// Execute template
	tmpl := templates.Lookup("data_source.go.tmpl")
	if tmpl == nil {
		return fmt.Errorf("data_source.go.tmpl not found")
	}

	var buf strings.Builder
	if err := tmpl.Execute(&buf, data); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	// Add generation header
	code := addGenerationHeader(buf.String())

	if dryRun {
		fmt.Printf("\n=== %s_data_source_generated.go ===\n%s\n", ds.Name, code)
		return nil
	}

	// Write to file
	filename := filepath.Join(outputDir, fmt.Sprintf("%s_data_source_generated.go", ds.Name))
	if err := os.WriteFile(filename, []byte(code), 0600); err != nil {
		return fmt.Errorf("failed to write file: %w", err)
	}

	return nil
}

// prepareTemplateData converts spec into template-friendly data
func prepareTemplateData(name string, schema SchemaSpec) TemplateData {
	pascalName := toPascalCase(name)

	data := TemplateData{
		ResourceName:     pascalName,
		TypeName:         name,
		Description:      fmt.Sprintf("Manages an Arcane %s.", name),
		CreateMethod:     fmt.Sprintf("Create%s", pascalName),
		ReadMethod:       fmt.Sprintf("Get%s", pascalName),
		UpdateMethod:     fmt.Sprintf("Update%s", pascalName),
		DeleteMethod:     fmt.Sprintf("Delete%s", pascalName),
		ReadByNameMethod: fmt.Sprintf("Get%sByName", pascalName),
	}

	// Convert attributes
	for _, attr := range schema.Attributes {
		if attr.Name == "id" {
			continue // ID is handled separately
		}

		attrData := convertAttribute(attr)
		data.Attributes = append(data.Attributes, attrData)
	}

	return data
}

// convertAttribute converts an AttributeSpec to AttributeData for templates
func convertAttribute(attr AttributeSpec) AttributeData {
	data := AttributeData{
		Name:        attr.Name,
		FieldName:   toPascalCase(attr.Name),
		TFName:      attr.Name,
		Description: attr.Description,
	}

	// Determine type and computed_optional_required
	var typeSpec *TypeSpec
	if attr.String != nil {
		data.Type = "String"
		data.SchemaType = "String"
		typeSpec = attr.String
	} else if attr.Int64 != nil {
		data.Type = "Int64"
		data.SchemaType = "Int64"
		typeSpec = attr.Int64
	} else if attr.Bool != nil {
		data.Type = "Bool"
		data.SchemaType = "Bool"
		typeSpec = attr.Bool
	} else if attr.Float64 != nil {
		data.Type = "Float64"
		data.SchemaType = "Float64"
		typeSpec = attr.Float64
	}

	if typeSpec != nil {
		data.Sensitive = typeSpec.Sensitive
		if data.Description == "" {
			data.Description = typeSpec.Description
		}

		switch typeSpec.ComputedOptionalRequired {
		case "required":
			data.Required = true
		case "optional":
			data.Optional = true
		case "computed":
			data.Computed = true
		case "computed_optional":
			data.Computed = true
			data.Optional = true
		}
	}

	return data
}

// toPascalCase converts snake_case to PascalCase
func toPascalCase(s string) string {
	parts := strings.Split(s, "_")
	for i, part := range parts {
		if len(part) > 0 {
			parts[i] = strings.ToUpper(part[:1]) + part[1:]
		}
	}
	return strings.Join(parts, "")
}

// addGenerationHeader adds a comment header to generated code
func addGenerationHeader(code string) string {
	header := `// Code generated by terraform-provider-arcane/generator. DO NOT EDIT.
//
// This file was automatically generated from the provider spec.
// To regenerate, run: make generate-crud

`
	return header + code
}
